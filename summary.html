<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>개념 정리</title>
        <link href="style.css" rel="stylesheet" type="text/css">
    </head>
    <body>
        <h2>개념 정리</h2>
        <ul class="bul_list">
            <li>[변수, 함수]이름: 카멜 케이스(firstCase), [생성자 함수, 클래스]이름: 파스칼케이스(FirstCase) </li>
            <li>문자열 타입(2바이트), 숫자 타입(8바이트)</li>
        </ul>
        <p>1. Ajax: 자바크스립트를 이용해 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신 기능</p>
        <p>2. Node.js: 구글 V8자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경, 자바스크립트 엔진을 브라우저에서 독립시킨 자바스크립트 실행 환경,<br>
            비동기 I/O를 지원하며 단일 스레드이벤트 루프 기반으로 동작함으로써 요청 처리 성능이 좋다.</p>
        <p>3. 웹 크롤링(web crawling): 서버에서 웹사이트의 콘텐츠를 수집하기 위해 웹사이트에서 HTML문서를 가져온 다음, 이를 가공해서 필요한 데이터만 추출</p>
        <p>4. npm(node package manager): 자바스크립트 패키지 매니저. Node.js에서 사용할 수 있는 모듈들을 패키지화해서 모아둔 저장소 역할과 패키지 설치 및 관리를 위한 CLI를 제공.</p>
        <p>5. 식별자는 값이 아니라 메모리 주소를 기억한다. 메모리 주소에 붙인 이름이라고 할수 있음.</p>
        <p>6. 일반적으로 '초기화'란 변수가 선언된 이후 최초로 값을 할당하는 것을 말함. 자바스크립트는 선언시 자동으로 undefined를 초기값으로 할당함</p>
        <p>7. 호이스팅(hoisting): 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징-> *모든 식별자(변수,함수,클래스 등)는 호이스팅된다.<br>
            -> 변수 선언: 런타임 이전에 먼저 실행, 값의 할당: 런타임에 순차적 실행, ==> 하나의 문으로 단축표현해도 같은 결과임.
        </p>
        <p>자바스크립트는 <a class="fc_orange">대소문자를 구별함</a>, <a class="fw_bold fc_purple">** 값으로 평가될 수 있는 문은 모두 표현식이다!!</a></p>
        <p>8. 문(statement): 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다.</p>
        <p>9. 토큰(token): 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.(문은 여러 토큰으로 구성된다.</p>
        <p>10. 키워드(keyword): 자바스크립트 코드를 해석하고 실행하는 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어이다. </p>
        <p>11. 숫자타입은 정수를 위한 타입이 없고 모든 수를 실수로 처리한다. 따라서 <a class="fw_bold fc_purple">정수로 표시된 수끼리 나누더라도 실수가 나올 수 있다!!</a></p>
        <p>12. 템플릿 리터럴: 문자열 표기법, 일반적인 따옴표 대신 백틱(``)을 사용함, 이스케이프 시퀀스를 사용하지 않고도 줄바꿈,공백도 있는 그대로 표시가 됨</p>
        <p>13. 자바스크립트의 경우 변수 선언시 암묵적 정의가(undefined) 되므로 선언과 정의의 구분이 모호하다. 그러므로 <strong class="fc_purple">변수는 '선언한다' 함수는 '정의한다'로 표현</strong></p>
        <p>14. 심벌(symbol): 변경 불가능한 원시 타입의 값. 심벌 값은 다른 값과 중복되지 않는 유일무이한 값,따라서 주로 이름이 충돌할 위헙이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용(33장)</p>
        <p>15. 문자열 연결 연산자에서 treu= 1, false= 0, null= 0 , undefined = NaN으로 타입 변환 </p>
        <p>16. 동등비교(==)연산자는 암묵적 타입변화로 인해 결과를 예측하기 힘들어 <strong class="fc_purple">일치 비교 연산자(===)를 사용하는 것이 좋다.(암묵적 타입변화를 하지않고 비교를 하기 때문에)</strong><br>
            <strong class="fc_purple">NaN은 자신과 일치하지 않는 유일한 값이다.</strong> 따라서 숫자가 NaN인지 조사하려면 빌트인 함수 <strong class="fc_red">Number.isNaN</strong>을 사용한다.<br>
            -0,+0을 일치비교연산자(===)로 하면 true로 정확한 결과가 안나옴, 이때는 <strong class="fc_red">Object.js()</strong>를 사용한다. ex) Object.js(-0,+0) => false 로 정확한 결과가 나옴.
        </p>
        <p>17. 삼항 조건 연산자: 조건식? true시 반환할 값: false시 반환할 값, <strong class="fc_purple">값으로 평가할 수 있는 표현식인 문이다!</strong><br>
            ex) var x = 2; var result = x % 2 ? '홀수' : '짝수' // 2%2 은 0이므로 'false' -> result = '짝수' 가 할당됨
        </p>
        <p>18. 논리부정(!) 연산자는 언제나 불리언 값을 반환한다. 암묵적 타입 변화를 함 ex) !0; //true</p>
        <p class="fc_orange">19. null 타입인지 확인할 때는 typeof 연산자가 아닌 <strong class="fc_red">일치 연산자(===)</strong>를 사용한다! <br>
        -> typeof 연산자로 null 값을 연산해 보면 "object"를 반환하기 때문이다(버그)
        </p>
        <p>20. 프로토타입(prototype): 어떤 객체의 상위(부모) 객체의 역할을 하는 객체다. 프로토타입은 하위(자식) 객체에게 자신의 프로퍼티와 메서드를 상속한다.</p>
        <hr>
        <h3>8장 제어문</h3>
        <p>1. 레이블문이란 식별자가 붙은 문이라 함. 레이블문을 탈출하려면 break문에 리이블 식별자를 지정한다. ex) foo: { console.log(1); break foo; // foo 레이블문을 탈출함 } <br>
            내부 for문이 아닌 외부 for문을 탈출하려면 레이블 문을 사용한다.(중첩 for문 외부로 탈출할때 유용하지만 그 밖의 경우에는 일반적으로 권장하지 않음.)
        </p>
        <hr>
        <h3>9장 타입 변환과 단축 평가</h3>
        <h4>1. 암묵적 타입 변환</h4>
        <p>1) + 연산자는 피연산자 중 하나 이상이 문자열이면 문자열 연결 연산자로 동작한다. ex) 1 + '12' // -> "112" <br>
            + 단항 연산자는 피연산자가 숫자 타입의 값이 아니면 숫자타입의 값으로 암묵적 타입변환을 한다. ex) +0 // -> 0
        </p>
        <p>2) [숫자타입으로 변환] <strong class="fc_purple">빈 문자열(''), 빈 배열[], null, false는 0으로,</strong> true는 1로 변환된다. 객체와 빈 배열이 아닌 배열, undifined는 변환되지 않아 NaN이 된다!!!</p>
        <p>3) [불리언 타입으로 변환] false값으로 평가되는 것들: false, undifined, null, 0, -0, NaN, ''(빈 문자열), <strong class="fc_purple">빈 문자열이 아닌 문자열은 true 값이다!!</strong>, <strong class="fc_red">[] {} 모두 true를 반환</strong></p>
        <h4>2. 명시적 타입 변환</h4>
        <p>1) 문자열 타입으로 변환 <br>
         - String 생성자를 new 연산자 없이 호출하는 방법 ex) String(1); // "1" <br>
         - Object.prototype.toString 메서드를 사용하는 방법 ex) (NaN).toString(); // "NaN" <br>
         - + 문자열 연결 연산자를 이용하는 방법 ex) true + ''; // "true"
        </p>
        <p>2) 숫자 타입으로 변환 <br>
         - Nunber 생성자 함수를 new 연산자 없이 호출하는 방법 ex) Number(false); // 0  <br>
         - parseInt, parseFloat 함수를 사용하는 방법(문자열만 숫자타입으로 변환 가능) ex) parseInt(-1); // -1 <br>
         - + 단항 산술 연산자를 이용하는 방법 ex) +'0'; // 0, +'true'; // 1<br>
         - * 산술 연산자를 이용하는 방법 <strong class="fc_red">ex) false * 1; // 0</strong>
        </p>
        <p>3) 불리언 타입으로 변환 <br>
         - Boolean 생성자 함수를 new 연산자 없이 호출하는 방법 ex) Boolean('false'); // true, Boolean(''); // false<br>
         - ! 부정 논리 연산자를 <strong class="fc_red">두번</strong> 사용하는 방법 ex) !!Infinity; // true, !!{}; // true
        </p>
        <h4>3. 단축평가</h4>
        <p>* 단축 평가: 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환하는 것</p>
        <p>* 단축평가를 통해 논리연산을 수행한다!</p>
        <p>1) 논리연산자를 사용한 단축 평가</p>
        <p>- 논리합(||): 논리 연산의 결과를 결정하는 두번째 피연산자를 반환한다. ex) false || 'anythig' // "anythig" , 'cat' || false // "cat"</p>
        <p>- 논리곱(&&): 논리 연산의 결과를 결정하는 첫번째 피연산자를 반환한다. ex) false && 'cat' // false, 'cat' && 'dog' // dog</p>
        <p>2) 옵셔널 체이닝 연산자(?.): 좌항의 피연산자가 null 또는 undefined인 경우 <strong class="fc_red">undefined를 반환</strong>하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다. <br> 
            * 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때 유용하다.</p>
        <p>3) null 병합 연산자(??): 좌항의 피연산자가 null 또는 undefined인 경우 <strong class="fc_red">우항의 피연산자를 반환</strong>하고, 그렇지 않으면 우항의 피연산자를 반환한다. <br> 
            * 변수에 기본값을 설정할 때 유용하다. </p>
        <hr>
        <h3>10장 객체 리터럴</h3>
        <p>- 모든 값은 프로퍼티가 될 수 있다. <strong class="fc_orange">함수 또한 값으로 취급하여 프로퍼티가 될 수있는데</strong> 이를 <strong class="fc_red">메서드</strong>라 부른다.</p>
        <p>- 객체 구성요소) 프로퍼티: 객체의 상태를 나타내는 값, 메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작 </p>
        <p>- 객체 리터럴은 값이라 중괄호(코드 블록) 뒤에 세미콜론(;)이 붙음.</p>
        <p>- 프로퍼티의 키는 네이밍 규칙을 따르지 않아도 되며 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야한다.(규칙 준수 시 생략 가능) </p>
        <p>- 프로퍼티 접근 하는 방법 <br>
            1) 마침표 프로퍼티 접근 연산자(.)를 사용하는 마침표 표기법 <br>
            2) 대괄호 프로퍼티 접근 연산자([...])를 사용하는 대괄호 표기법 : 내부에 지정하는 프로퍼티 키는 반드시 <strong class="fc_orange">따옴표로 감싼 문자열</strong>이어야 한다.
        </p>
        <p>- 객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환한다. 이때 <strong class="fc_red">ReferenceError가 발생하지 않는다!!</strong></p>
        <p>- 프로퍼티 동적 생성: 존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당 된다.</p>
        <p>- 프로퍼티 삭제: delete 연산자 사용. 객체에 존재하지 않는 프로퍼티 삭제시 에러가 안나고 무시됨. ex) delete person.age;</p>
        <p>- [ES6] 프로퍼티 값은 변수에 할당된 값, 즉 식별자로 표현 가능하다. ex) var object = { x = x, y = y}; <br>
            이때 변수 이름과 프로퍼티 키의 이름이 같을 경우 프로퍼티 키를 생략할 수 있다. 이때 프로퍼티 키는 변수 이름으로 자동 생성된다. ex) const obj = {x , y};
        </p>
        <p>- 계산된 프로퍼티 이름: 문자열로 타입변환할 수 있는 값으로 평가되는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수 있다. <br>
            -> [ES5] (객체 <strong class="fc_orange">외부</strong>에서 생성) ex) var i = 0; var obj = {}; obj[prefix + '-' + ++i] = i; <br>
            -> [ES6] (객체 <strong class="fc_orange">내부</strong>에서 생성) ex) const obj = { [`${prefix} - ${++i}`]: i, ... }; // 백틱(``) 사용
        </p>
        <p>- 메서드 축약 표현: 축약 표현한 메서드는 프로퍼티에 할당한 함수와 다르게 동작한다. <br> 
            ex) var obj = { sayHi: function() {...} }; -> [ES6] const obj = { sayHi() {...} };
        </p>
        <hr>
        <h3>11장 원시 값과 객체의 비교</h3>
        <ul class="bul_list">
            <li> 원시 값은 변경 불가능한 값으로 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 <strong class="fc_orange">원시 값이 복사</strong>되어 전달된다.</li>
            <li> 객체 타입의 값은 객체(참조)응 변경 가능한 값이고, 다른 변수에 할당하면 원본의 <strong class="fc_orange">참조값이 복사</strong>되어 전달 된다.</li>
        </ul>
        <p>1) 원시 값: 변경 불가능한 값 <br>
            - 문자열과 불변성: 문자열은 원시값이다. 문자열은 유사 배열 객체이면서 이터러블 이므로 배열과 유사하게 각 문자에 접근할 수 있다. <br>
                * 유사 배열 객체: 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말함. ex) str.length , str[0] ... <br>
            - 값에 의한 전달: 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수의 원시 값이 <strong class="fc_red">복사</strong>되어 전달된다. <br>
            -> <strong class="fc_red">다른 메모리 공간에 저장된 별개의 값이다.</strong>
        </p>
        <p>2) 객체 값: 변경 가능한 값 -> 여러개의 식별지가 하나의 객체를 공유할 수 있음(공유하는 객체를 변경하면 서로 영향을 주고 받음)
        </p>
        <p>=> JS에서는 "참조에 의한 전달"은 존재하지 않고 "값에 의한 전달"만이 존재한다.</p>
        <hr>
        <h3>12장 함수</h3>
        <ul class="bul_list">
            <li>함수는 함수 이름으로 호출하는 것이 아닌 함수 객체를 가리키는 식별자로 호출한다.</li>
            <li>함수는 일급 객체이다: 함수를 <strong class="fc_red">값</strong>처럼 자유롭게 사용할 수 있다는 것</li>
            <li class="fc_orange">함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않는다. 즉 에러가 발생하지 않는다. -> 인수가 할당되지 않는 매개변수의 값은 undefined이다, 초과된 인수는 무시된다.</li>
            <li>반환문은 생략할 수 있다. 암묵적으로 undefined를 반환한다.</li>
            <li>return 키워드 뒤에 반환값으로 사용할 표현식을 명시적으로 지정하지 않으면 undefined가 반환된다.</li>
        </ul>

        <h4>1. 함수 리터럴 <strong class="fc_blue">ex) var f = function add(a,y) { return a+y; }</strong></h4>
        <ul class="dash_list">
            <li>함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.</li>
            <li class="fc_orange">함수 이름은 생략할 수 있다.</li>
            <li>함수 리터럴도 평가되어 <strong class="fc_red">값을 생성</strong>하며, 그러므로 함수는 <strong class="fc_red">객체</strong>다.</li>
        </ul>
        <h4>2. 함수 정의</h4>
        <p>1) 함수 선언문  <strong class="fc_blue">ex) function add(x,y) { return x+y; }</strong>
            <ul class="dash_list">
                <li>함수 이름을 생략할 수 없다.</li>
                <li>표현식이 아닌 <strong class="fc_orange">문</strong>이다. 콘솔에서 함수 선언문 실행 시 <strong class="fc_orange">undefined를 반환함</strong> (값으로 평가되는 문을 표현식이라고 함!!)</li>
                <li>원래는 함수이름으로 함수를 호출할 수 없지만(값으로 평가 되므로 식별자가 없음), <strong class="fc_orange">자바스크립트 엔진이 암묵적으로 식별자를 생성하여 함수이름과 같은 식별자로 호출이 가능하다.</strong></li>
            </ul>
        </p>
        <p></p>
        <p>2) 함수 표현식  <strong class="fc_blue">ex) var add = function (x,y) { return x+y; }</strong>
            <ul class="dash_list">
                <li>함수 이름을 생략할 수 있다 (익명함수)</li>
                <li>함수 선언문은 "표현식이 아닌 문"(= 값)이고 함수 표현식은 "표현식인 문"이다.</li>
            </ul>
        </p>
        <p>3) 함수 호이스팅: 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 고유 특징을 말한다.
            <ul class="dash_list">
                <li>런타임 이전에 자바스크립트 엔진이 실행하는데 이때 함수 선언문의 객체가 먼저 생성한다. 이때 암묵적으로 식별자를 생성하기 때문에 함수 선언문으로 정의한 함수를 함수 선언문 이전에 참조, 호출 할 수 있다.</li> 
                <li>함수 표현식은 변수 할당문의 실행되는 시점, 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다. => 함수 표현식 이전에 참조, 호출할 수 없다.</li>
            </ul>
        </p>
        <p>4) Function 생성자 함수  <strong class="fc_blue">ex) var add = new Function ( x, y, 'return x+y' );</strong>
            <ul class="dash_list">
                <li>함수를 생성하는 방식은 일반적이지 않으며 클로저를 생성하지 않는 등, 바람직 하지 않다. </li>
            </ul>
        </p>
        <p>5) 화살표 함수  <strong class="fc_blue">[ES6] ex) const add = (x, y) => x + y;</strong>
            <ul class="dash_list">
                <li>항상 익명함수로 정의한다. -> 26.3절에서 더 정확하게 나옴</li>
            </ul>
        </p>
        <h4>3. 다양한 함수의 형태</h4>
        <p>1) 즉시 실행 함수  <strong class="fc_blue">ex) (function(){var a = 3; var b = 2; return a*b; }();); -> (); :는 함수 호출 연산자임</strong>
            <ul class="dash_list">
                <li>익명함수를 사용하는 것이 일반적이다.</li>
                <li>즉시 실행 함수는 한번만 호출되며 다시 호출할 수 없다.</li>
                <li>반드시 그룹연산자(..)로 감싸야 한다.</li>
                <li>일반 함수 처럼 값을 반환할 수 있고 인수를 전달할 수 있다!</li>
            </ul>
        </p>
        <p>2) 재귀 함수: 자기 자신을 호출하는 행위, 즉 재귀 호출을 수행하는 함수를 말한다.</p>
        <p>3) 콜백 함수
            <ul class="dash_list">
                <li>콜백 함수: 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수</li>
                <li>고차 함수: 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수</li>
                <li>고차 함수는 콜백 함수를 자신의 일부분으로 합성한다.</li>
            </ul> 
        </p>
        <p>4) 순수 함수와 비순수 함수
            <ul class="dash_list">
                <li>순수 함수: 부수효과가 없는 함수, 최소 하나 이상의 인수를 전달 받으며, 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수다.</li>
                <li>비순수 함수: 부수효과가 있는 함수, 외부 상태에 의존하거나 외부 상태를 변셩하는 함수다.</li>
            </ul>
        </p>
        <hr>
        <h3>13장 스코프: 식별자가 유효한 범위</h3>
        <ul class="bul_list">
            <li>렉시컬 환경(lexical environment): 코드가 어디서 실행되며 주변에 어떤 코드가 있는지</li>
            <li>실행 컨텍스트(excution context): 코드의 문맥은 렉시컬 환경으로 이루어지며 이를 구현한 것, 모든 코드는 실행 컨텍스트애서 평가되고 실행된다.</li>
            <li>전역 스코프: 전역변수, 코드의 가장 바깥 영역</li>
            <li>지역 스코프: 지역변수(자역 스코프와 하위 지역 스코프에서 유효하다.), 함수 몸체 내부</li>
            <li class="fc_orange">변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.</li>
        </ul>
        <h4>1. 스코프 체인: 스코프가 계층적으로 연결된 것</h4>
            <ul class="dash_list">
                <li>스코프 체인은 물리적인 실체로 존재하며 자료구조인 렉시컬 환경을 실제로 생성한다.</li>
                <li>스코프 체인은 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결한 것이다.</li>
            </ul>
        
        <h4>2. 함수 레벨 스코프: var 키워드로 선언된 변수는 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정한다. </h4>
            <ul class="dash_list">
                <li>함수 밖에서 var키워드로 선언된 변수는 코드 블록 내에서 선언되었다 할지라도 모두 전역 변수이다. <br>
                    -> 따라서 전역 변수 x는 중복 선언되고 의도치 않는 전역 변수의 값이 재할당된다.
                </li>
                <li>let, const는 블록 레벨 스코프를 지원한다.</li>
            </ul>
       
        <h4>3. 렉시컬 스코프 (== 정적 스코프) </h4>
            <ul class="dash_list">
                <li>함수를 어디서 정의했는지에 따라 상위 스코프가 결정된다.</li>
                <li>함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다.</li>
                <li>함수의 상위 스코프는 함수 정의가 실행될 때 정적으로 결정된다.</li>
            </ul>
       
        <hr>
        <h3>14장 전역 변수의 문제점</h3>
        <h4>1. 변수의 생명주기 </h4>
            <ul class="dash_list">
                <li>변수는 자신이 선언된 위치에서 생성되고 소멸하는데, <strong class="fc_blue">전역변수의 생명주기</strong>는 <strong class="fc_orange">애플리케이션의 생명주기와 같고</strong>, 
                    <strong class="fc_blue">지역변수</strong>는 <strong class="fc_orange">함수가 호출되면 생성되고 함수가 종료하면 소멸한다.</strong></li>
                <li>var 키워드로 선언한 전역 변수는 전역객체의 프로퍼티가 된다. 전역변수의 생명주기가 전역객체의 생명주기와 같다.</li>
                <li>전역 객체: 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이다.
                    <ul class="bul_list">
                        <li>클라이언트 사이드 환경(브라우저)에서는 window, 서버사이드 화면(node.js)에서는 global객체를 의미한다.</li>
                        <li>전역객체를 가리키는 다양한 식별자(window,self,this,frames,global)이 존재 했으나 ES11에서 globalThis로 통일 되었다.</li>
                    </ul>
                </li>
            </ul>
       
        <h4>2. 전역변수의 사용을 억제하는 방법</h4>
            <ul class="dash_list">
                <li>함수 정의와 동시에 호출되는 즉시실행함수로 감싼다.</li>
                <li>네임 스페이스 객체 사용  <strong class="fc_blue">ex) var MYAPP={}; MYAPP.name = 'Lee';</strong> 
                    <ul class="bul_list">
                        <li>전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법이다.</li>
                        <li>네임스페이스 객체 자체가 전역 변수에 할당되므로 유용하지는 않다.</li>
                    </ul>
                </li>
                <li>모듈 패턴: 클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다. 클로저를 기반으로 동작한다.</li>
                <li>ES6모듈: 파일 자체의 독자적인 모듈 스코프를 제공한다.</li>
            </ul>
        
        <hr>
        <h3>15장 let, const 키워드와 블록 레벨 스코프</h3>
        <ul class="bul_list">
            <li>변수 선언 시 const 키워드를 사용하는 것이 좋으며 재할당이 필요할때 let키워드를 사용한다.</li>
        </ul>
        <h4>1. var 키워드로 선언한 변수의 문제점</h4>
            <ul class="dash_list">
                <li><strong class="fc_purple">변수 중복 선언 허용</strong>: 중복 선언 시 재할당 우려가 있음</li>
                <li><strong class="fc_purple">함수 레벨 스코프</strong>: 함수 외부에서 var키워드로 선언한 변수는 코드블록 내에서 선언해도 모두 전역변수가 되므로(변수 중복 선언) 재할당 우려가 있다.</li>
                <li><strong class="fc_purple">변수 호이스팅</strong>: 변수 선언문 이전에 참조할 수 있다.(undefined로 반환)</li>
            </ul>
        
        <h4>2. let 키워드 </h4>
            <ul class="dash_list">
                <li class="fc_orange">변수 중복 선언 금지</li>
                <li>블록 레벨 스코프: 모든 코드 블록(함수, if문, for문, while문, try/catch문 등)을 지역 스코프로 인정한다.</li>
                <li>변수 호이스팅이 발생하지 않는 것처럼 동작한다.: 런타임 이전에 변수 선언을 하고 런타임에서 변수 선언문에 도달 했을때 초기화단계를 실행한다.(초기화:undefined), 일시적 사각지대에 있다. <br>
                * 일시적 사각지대: 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간
                </li>
            </ul>
       
        <h4>3. const 키워드: 상수를 선언하기 위해 사용함, let특징과 같음, 아래 내용은 let키워르와 다른점이다. </h4>
            <ul class="dash_list">
                <li class="fc_orange">const키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.</li>
                <li class="fc_red">재할당 금지!!, 불변을 의미하는 것은 아니다.</li>
                <li class="fc_orange">상수: 일반적으로 상수의 이름은 대문자로 선언한다. 여러단어로 이루어진 경우 언더스코어(_)로 구분해 스네이크 케이스로 표현한다.</li>
                <li>const 키워드로 선언된 변수에 <strong class="fc_orange">객체를 할당할 경우 값을 변경할 수 있다.</strong> -> 객체는 재할당 없이도 직접 변경이 가능하기 때문이다. </li>
            </ul>
   
        <hr>
        <h3>16장 프로퍼티 어트리뷰트</h3>
        <h4>1. 내부 슬럿과 내부 메서드: 이중 대괄호([[...]])로 감싼 이름들이 내부슬롯과 내부메서드인데 개발자가 직접 접근할 수 없다. </h4>
            <ul class="dash_list">
                <li>모든 객체는 [[prototype]]이라는 내부 슬롯을 갖는다. [[prototype]]의 경우 _ _proto_ _를 통해 간접적으로 접근할 수 있다.</li>
            </ul>
       
        <h4>2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체</h4>
            <ul class="dash_list">
                <li>자바스크립트 엔진은 <strong class="fc_orange">프러퍼티를 생성할 때</strong> 프로퍼티의 상태를 나타내는 <strong class="fc_orange">프로퍼티 어트리뷰트를 기본값으로 자동 정의</strong>한다.</li>
                <li>프로퍼티 어트리뷰트는 Object.getOwnProperDescription 메서드를 사용하여 간접적으로 확인할 수 있다.</li>
            </ul>
        
        <h4>3. 데이터 프로퍼티와 접근자 프로퍼티</h4>
        <p>1) 데이터 프로퍼티: 키와 값으로 구성된 일반적인 프로퍼티다.
            <ul class="dash_list">
                <li>프로퍼티 어트리뷰트: [[Value]] - 반환되는 값, [[Writable]] - 값의 변경 여부(불린), [[Enumerable]] - 열거 가능 여부, [[configurable]] - 재정의 가능 여부</li>
            </ul>
        </p>
        <p>2) 접근자 프로퍼티: <strong class="fc_orange">자체적 값을 갖지 않고</strong> 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티이다.
            <ul class="dash_list">
                <li>프로퍼티 어트리뷰트: [[Get]] - 값을 읽을때 getter함수 호출, [[Set] - 값을 저장할때 setter함수 호출, [[Enumerable]] - 열거 가능 여부, [[configurable]] - 재정의 가능 여부</li>
                <li>접근자 함수는 getter/setter함수 라고도 부름</li>
            </ul>
        </p>
        <p>* <strong class="fc_orange">일반 객체</strong>의 __proto__ 는 <strong class="fc_orange">접근자 프로퍼티</strong>이며, 
            <strong class="fc_orange">함수 객체</strong>의 prototype은 <strong class="fc_orange">데이터 프로퍼티</strong>이다.</p>
        <h4>4. 프로퍼티 정의: 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기본 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것 (p226.참고)</h4>
       
            <ul class="bul_list">
                <li>Object.defineProperty 메서드를 사용한다. 인수로는 객체의 참조, 데이터 프로퍼티의 키인 문자열, 프로퍼티 디스크립터 객체를 전달</li>
            </ul>
 
        <h4>5. 객체 변경 방지</h4>
        <ul class="bul_list">
            <li>프로퍼티 추가는 동적 추가와 Object.defineProperty 메서드로 추가할 수 있다.</li>
            <li></li>
        </ul>
        <p>1) 객체 확장 금지
            <ul class="dash_list">
                <li><strong class="fc_orange">Object.preventExtensions 메서드</strong>는 객체의 확장을 금지한다. -> 프로퍼티 추가 금지, 삭제와 프로퍼티 어트리뷰트 재정의는 가능 <br>
                    ex) Object.preventExtensions(객체 명); // 프로퍼티 추가가 금지됨.
                </li>
                <li>확장이 가능한 객체인지 여부는 Object.isExtensible(객체 명) 메서드로 확인 가능하다.</li>
            </ul>
        </p>
        <p>2) 객체 밀봉
            <ul class="dash_list">
                <li><strong class="fc_orange">Object.seal 메서드</strong>는 프로퍼티 추가, 삭제, 프로퍼티 어트리뷰트 재정의가 불가능 -> 읽기와 쓰기(값 갱신)은 가능하다.</li>
                <li>밀봉된 객체인지 여부는 Object.isSealed(객체 명) 메서드로 확인 가능하다.</li>
            </ul>
        </p>
        <p>3) 객체 동결
            <ul class="dash_list">
                <li><strong class="fc_orange">Object.freeze 메서드</strong>는 프로퍼티 추가, 삭제, 값 갱신, 프로퍼티 어트리뷰트 재정의가 불가능 -> 읽기만 가능하다.</li>
                <li>밀봉된 객체인지 여부는 Object.isFeozen(객체 명) 메서드로 확인 가능하다.</li>
            </ul>
        </p>
        <p>4) 불변 객체
            <ul class="dash_list">
                <li>1),2),3)의 방식은 <strong class="fc_orange">얕은 변경 방지</strong>로 직속 프로퍼티만 변경이 방지되고 중첩 객체까지는 영향을 주지 못한다. <br>
                    -> 깊은 변경 방지를 하기 위해서는 <strong class="fc_orange">재귀적으로 해당 메서드를 호출</strong>해야한다.</li>
            </ul>
        </p>
        <p></p>
        <p></p>
        <hr>
        <h2>단축어</h2>
        <p>터미널: cmd + ;</p>
        <p>ctl + option + n: 현재 포커스된 js파일이 살행됨</p>
        <p>f5: cmd + R</p>
    </body>
</html>

