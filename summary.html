<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>개념 정리</title>
        <link href="style.css" rel="stylesheet" type="text/css">
    </head>
    <body>
        <h2>개념 정리</h2>
        <ul class="bul_list">
            <li>[변수, 함수]이름: 카멜 케이스(firstCase), [생성자 함수, 클래스]이름: 파스칼케이스(FirstCase) </li>
            <li>문자열 타입(2바이트), 숫자 타입(8바이트)</li>
        </ul>
        <p>1. Ajax: 자바크스립트를 이용해 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신 기능</p>
        <p>2. Node.js: 구글 V8자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경, 자바스크립트 엔진을 브라우저에서 독립시킨 자바스크립트 실행 환경,<br>
            비동기 I/O를 지원하며 단일 스레드이벤트 루프 기반으로 동작함으로써 요청 처리 성능이 좋다.</p>
        <p>3. 웹 크롤링(web crawling): 서버에서 웹사이트의 콘텐츠를 수집하기 위해 웹사이트에서 HTML문서를 가져온 다음, 이를 가공해서 필요한 데이터만 추출</p>
        <p>4. npm(node package manager): 자바스크립트 패키지 매니저. Node.js에서 사용할 수 있는 모듈들을 패키지화해서 모아둔 저장소 역할과 패키지 설치 및 관리를 위한 CLI를 제공.</p>
        <p>5. 식별자는 값이 아니라 메모리 주소를 기억한다. 메모리 주소에 붙인 이름이라고 할수 있음.</p>
        <p>6. 일반적으로 '초기화'란 변수가 선언된 이후 최초로 값을 할당하는 것을 말함. 자바스크립트는 선언시 자동으로 undefined를 초기값으로 할당함</p>
        <p>7. 호이스팅(hoisting): 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징-> *모든 식별자(변수,함수,클래스 등)는 호이스팅된다.<br>
            -> 변수 선언: 런타임 이전에 먼저 실행, 값의 할당: 런타임에 순차적 실행, ==> 하나의 문으로 단축표현해도 같은 결과임.
        </p>
        <p>자바스크립트는 <a class="fc_orange">대소문자를 구별함</a>, <a class="fw_bold fc_purple">** 값으로 평가될 수 있는 문은 모두 표현식이다!!</a></p>
        <p>8. 문(statement): 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다.</p>
        <p>9. 토큰(token): 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.(문은 여러 토큰으로 구성된다.</p>
        <p>10. 키워드(keyword): 자바스크립트 코드를 해석하고 실행하는 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어이다. </p>
        <p>11. 숫자타입은 정수를 위한 타입이 없고 모든 수를 실수로 처리한다. 따라서 <a class="fw_bold fc_purple">정수로 표시된 수끼리 나누더라도 실수가 나올 수 있다!!</a></p>
        <p>12. 템플릿 리터럴: 문자열 표기법, 일반적인 따옴표 대신 백틱(``)을 사용함, 이스케이프 시퀀스를 사용하지 않고도 줄바꿈,공백도 있는 그대로 표시가 됨</p>
        <p>13. 자바스크립트의 경우 변수 선언시 암묵적 정의가(undefined) 되므로 선언과 정의의 구분이 모호하다. 그러므로 <strong class="fc_purple">변수는 '선언한다' 함수는 '정의한다'로 표현</strong></p>
        <p>14. 심벌(symbol): 변경 불가능한 원시 타입의 값. 심벌 값은 다른 값과 중복되지 않는 유일무이한 값,따라서 주로 이름이 충돌할 위헙이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용(33장)</p>
        <p>15. 문자열 연결 연산자에서 treu= 1, false= 0, null= 0 , undefined = NaN으로 타입 변환 </p>
        <p>16. 동등비교(==)연산자는 암묵적 타입변화로 인해 결과를 예측하기 힘들어 <strong class="fc_purple">일치 비교 연산자(===)를 사용하는 것이 좋다.(암묵적 타입변화를 하지않고 비교를 하기 때문에)</strong><br>
            <strong class="fc_purple">NaN은 자신과 일치하지 않는 유일한 값이다.</strong> 따라서 숫자가 NaN인지 조사하려면 빌트인 함수 <strong class="fc_red">Number.isNaN</strong>을 사용한다.<br>
            -0,+0을 일치비교연산자(===)로 하면 true로 정확한 결과가 안나옴, 이때는 <strong class="fc_red">Object.js()</strong>를 사용한다. ex) Object.js(-0,+0) => false 로 정확한 결과가 나옴.
        </p>
        <p>17. 삼항 조건 연산자: 조건식? true시 반환할 값: false시 반환할 값, <strong class="fc_purple">값으로 평가할 수 있는 표현식인 문이다!</strong><br>
            ex) var x = 2; var result = x % 2 ? '홀수' : '짝수' // 2%2 은 0이므로 'false' -> result = '짝수' 가 할당됨
        </p>
        <p>18. 논리부정(!) 연산자는 언제나 불리언 값을 반환한다. 암묵적 타입 변화를 함 ex) !0; //true</p>
        <p class="fc_orange">19. null 타입인지 확인할 때는 typeof 연산자가 아닌 <strong class="fc_red">일치 연산자(===)</strong>를 사용한다! <br>
        -> typeof 연산자로 null 값을 연산해 보면 "object"를 반환하기 때문이다(버그)
        </p>
        <hr>
        <h3>8장 제어문</h3>
        <p>1. 레이블문이란 식별자가 붙은 문이라 함. 레이블문을 탈출하려면 break문에 리이블 식별자를 지정한다. ex) foo: { console.log(1); break foo; // foo 레이블문을 탈출함 } <br>
            내부 for문이 아닌 외부 for문을 탈출하려면 레이블 문을 사용한다.(중첩 for문 외부로 탈출할때 유용하지만 그 밖의 경우에는 일반적으로 권장하지 않음.)
        </p>
        <hr>
        <h3>9장 타입 변환과 단축 평가</h3>
        <h4>1. 암묵적 타입 변환</h4>
        <p>1) + 연산자는 피연산자 중 하나 이상이 문자열이면 문자열 연결 연산자로 동작한다. ex) 1 + '12' // -> "112" <br>
            + 단항 연산자는 피연산자가 숫자 타입의 값이 아니면 숫자타입의 값으로 암묵적 타입변환을 한다. ex) +0 // -> 0
        </p>
        <p>2) [숫자타입으로 변환] <strong class="fc_purple">빈 문자열(''), 빈 배열[], null, false는 0으로,</strong> true는 1로 변환된다. 객체와 빈 배열이 아닌 배열, undifined는 변환되지 않아 NaN이 된다!!!</p>
        <p>3) [불리언 타입으로 변환] false값으로 평가되는 것들: false, undifined, null, 0, -0, NaN, ''(빈 문자열), <strong class="fc_purple">빈 문자열이 아닌 문자열은 true 값이다!!</strong>, <strong class="fc_red">[] {} 모두 true를 반환</strong></p>
        <h4>2. 명시적 타입 변환</h4>
        <p>1) 문자열 타입으로 변환 <br>
         - String 생성자를 new 연산자 없이 호출하는 방법 ex) String(1); // "1" <br>
         - Object.prototype.toString 메서드를 사용하는 방법 ex) (NaN).toString(); // "NaN" <br>
         - + 문자열 연결 연산자를 이용하는 방법 ex) true + ''; // "true"
        </p>
        <p>2) 숫자 타입으로 변환 <br>
         - Nunber 생성자 함수를 new 연산자 없이 호출하는 방법 ex) Number(false); // 0  <br>
         - parseInt, parseFloat 함수를 사용하는 방법(문자열만 숫자타입으로 변환 가능) ex) parseInt(-1); // -1 <br>
         - + 단항 산술 연산자를 이용하는 방법 ex) +'0'; // 0, +'true'; // 1<br>
         - * 산술 연산자를 이용하는 방법 <strong class="fc_red">ex) false * 1; // 0</strong>
        </p>
        <p>3) 불리언 타입으로 변환 <br>
         - Boolean 생성자 함수를 new 연산자 없이 호출하는 방법 ex) Boolean('false'); // true, Boolean(''); // false<br>
         - ! 부정 논리 연산자를 <strong class="fc_red">두번</strong> 사용하는 방법 ex) !!Infinity; // true, !!{}; // true
        </p>
        <h4>3. 단축평가</h4>
        <p>* 단축 평가: 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환하는 것</p>
        <p>* 단축평가를 통해 논리연산을 수행한다!</p>
        <p>1) 논리연산자를 사용한 단축 평가</p>
        <p>- 논리합(||): 논리 연산의 결과를 결정하는 두번째 피연산자를 반환한다. ex) false || 'anythig' // "anythig" , 'cat' || false // "cat"</p>
        <p>- 논리곱(&&): 논리 연산의 결과를 결정하는 첫번째 피연산자를 반환한다. ex) false && 'cat' // false, 'cat' && 'dog' // dog</p>
        <p>2) 옵셔널 체이닝 연산자(?.): 좌항의 피연산자가 null 또는 undefined인 경우 <strong class="fc_red">undefined를 반환</strong>하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다. <br> 
            * 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때 유용하다.</p>
        <p>3) null 병합 연산자(??): 좌항의 피연산자가 null 또는 undefined인 경우 <strong class="fc_red">우항의 피연산자를 반환</strong>하고, 그렇지 않으면 우항의 피연산자를 반환한다. <br> 
            * 변수에 기본값을 설정할 때 유용하다. </p>
        <hr>
        <h3>10장 객체 리터럴</h3>
        <p>- 모든 값은 프로퍼티가 될 수 있다. <strong class="fc_orange">함수 또한 값으로 취급하여 프로퍼티가 될 수있는데</strong> 이를 <strong class="fc_red">메서드</strong>라 부른다.</p>
        <p>- 객체 구성요소) 프로퍼티: 객체의 상태를 나타내는 값, 메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작 </p>
        <p>- 객체 리터럴은 값이라 중괄호(코드 블록) 뒤에 세미콜론(;)이 붙음.</p>
        <p>- 프로퍼티의 키는 네이밍 규칙을 따르지 않아도 되며 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야한다.(규칙 준수 시 생략 가능) </p>
        <p>- 프로퍼티 접근 하는 방법 <br>
            1) 마침표 프로퍼티 접근 연산자(.)를 사용하는 마침표 표기법 <br>
            2) 대괄호 프로퍼티 접근 연산자([...])를 사용하는 대괄호 표기법 : 내부에 지정하는 프로퍼티 키는 반드시 <strong class="fc_orange">따옴표로 감싼 문자열</strong>이어야 한다.
        </p>
        <p>- 객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환한다. 이때 <strong class="fc_red">ReferenceError가 발생하지 않는다!!</strong></p>
        <p>- 프로퍼티 동적 생성: 존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당 된다.</p>
        <p>- 프로퍼티 삭제: delete 연산자 사용. 객체에 존재하지 않는 프로퍼티 삭제시 에러가 안나고 무시됨. ex) delete person.age;</p>
        <p>- [ES6] 프로퍼티 값은 변수에 할당된 값, 즉 식별자로 표현 가능하다. ex) var object = { x = x, y = y}; <br>
            이때 변수 이름과 프로퍼티 키의 이름이 같을 경우 프로퍼티 키를 생략할 수 있다. 이때 프로퍼티 키는 변수 이름으로 자동 생성된다. ex) const obj = {x , y};
        </p>
        <p>- 계산된 프로퍼티 이름: 문자열로 타입변환할 수 있는 값으로 평가되는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수 있다. <br>
            -> [ES5] (객체 <strong class="fc_orange">외부</strong>에서 생성) ex) var i = 0; var obj = {}; obj[prefix + '-' + ++i] = i; <br>
            -> [ES6] (객체 <strong class="fc_orange">내부</strong>에서 생성) ex) const obj = { [`${prefix} - ${++i}`]: i, ... }; // 백틱(``) 사용
        </p>
        <p>- 메서드 축약 표현: 축약 표현한 메서드는 프로퍼티에 할당한 함수와 다르게 동작한다. <br> 
            ex) var obj = { sayHi: function() {...} }; -> [ES6] const obj = { sayHi() {...} };
        </p>
        <hr>
        <h3>11장 원시 값과 객체의 비교</h3>
        <ul class="bul_list">
            <li> 원시 값은 변경 불가능한 값으로 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 <strong class="fc_orange">원시 값이 복사</strong>되어 전달된다.</li>
            <li> 객체 타입의 값은 객체(참조)응 변경 가능한 값이고, 다른 변수에 할당하면 원본의 <strong class="fc_orange">참조값이 복사</strong>되어 전달 된다.</li>
        </ul>
        <p>1) 원시 값: 변경 불가능한 값 <br>
            - 문자열과 불변성: 문자열은 원시값이다. 문자열은 유사 배열 객체이면서 이터러블 이므로 배열과 유사하게 각 문자에 접근할 수 있다. <br>
                * 유사 배열 객체: 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말함. ex) str.length , str[0] ... <br>
            - 값에 의한 전달: 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수의 원시 값이 <strong class="fc_red">복사</strong>되어 전달된다. <br>
            -> <strong class="fc_red">다른 메모리 공간에 저장된 별개의 값이다.</strong>
        </p>
        <p>2) 객체 값: 변경 가능한 값 -> 여러개의 식별지가 하나의 객체를 공유할 수 있음(공유하는 객체를 변경하면 서로 영향을 주고 받음)
        </p>
        <p>=> JS에서는 "참조에 의한 전달"은 존재하지 않고 "값에 의한 전달"만이 존재한다.</p>
        <hr>
        <h3>12장 함수</h3>
        <ul class="bul_list">
            <li>함수는 함수 이름으로 호출하는 것이 아닌 함수 객체를 가리키는 식별자로 호출한다.</li>
            <li>함수는 일급 객체이다: 함수를 <strong class="fc_red">값</strong>처럼 자유롭게 사용할 수 있다는 것</li>
            <li class="fc_orange">함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않는다. 즉 에러가 발생하지 않는다. -> 인수가 할당되지 않는 매개변수의 값은 undefined이다, 초과된 인수는 무시된다.</li>
            <li>반환문은 생략할 수 있다. 암묵적으로 undefined를 반환한다.</li>
            <li>return 키워드 뒤에 반환값으로 사용할 표현식을 명시적으로 지정하지 않으면 undefined가 반환된다.</li>
        </ul>

        <h4>1. 함수 리터럴 <strong class="fc_blue">ex) var f = function add(a,y) { return a+y; }</strong></h4>
        <ul class="dash_list">
            <li>함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.</li>
            <li class="fc_orange">함수 이름은 생략할 수 있다.</li>
            <li>함수 리터럴도 평가되어 <strong class="fc_red">값을 생성</strong>하며, 그러므로 함수는 <strong class="fc_red">객체</strong>다.</li>
        </ul>
        <h4>2. 함수 정의</h4>
        <p>1) 함수 선언문  <strong class="fc_blue">ex) function add(x,y) { return x+y; }</strong>
            <ul class="dash_list">
                <li>함수 이름을 생략할 수 없다.</li>
                <li>표현식이 아닌 <strong class="fc_orange">문</strong>이다. 콘솔에서 함수 선언문 실행 시 <strong class="fc_orange">undefined를 반환함</strong> (값으로 평가되는 문을 표현식이라고 함!!)</li>
                <li>원래는 함수이름으로 함수를 호출할 수 없지만(값으로 평가 되므로 식별자가 없음), <strong class="fc_orange">자바스크립트 엔진이 암묵적으로 식별자를 생성하여 함수이름과 같은 식별자로 호출이 가능하다.</strong></li>
            </ul>
        </p>
        <p></p>
        <p>2) 함수 표현식  <strong class="fc_blue">ex) var add = function (x,y) { return x+y; }</strong>
            <ul class="dash_list">
                <li>함수 이름을 생략할 수 있다 (익명함수)</li>
                <li>함수 선언문은 "표현식이 아닌 문"(= 값)이고 함수 표현식은 "표현식인 문"이다.</li>
            </ul>
        </p>
        <p>3) 함수 호이스팅: 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 고유 특징을 말한다.
            <ul class="dash_list">
                <li>런타임 이전에 자바스크립트 엔진이 실행하는데 이때 함수 선언문의 객체가 먼저 생성한다. 이때 암묵적으로 식별자를 생성하기 때문에 함수 선언문으로 정의한 함수를 함수 선언문 이전에 참조, 호출 할 수 있다.</li> 
                <li>함수 표현식은 변수 할당문의 실행되는 시점, 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다. => 함수 표현식 이전에 참조, 호출할 수 없다.</li>
            </ul>
        </p>
        <p>4) Function 생성자 함수  <strong class="fc_blue">ex) var add = new Function ( x, y, 'return x+y' );</strong>
            <ul class="dash_list">
                <li>함수를 생성하는 방식은 일반적이지 않으며 클로저를 생성하지 않는 등, 바람직 하지 않다. </li>
            </ul>
        </p>
        <p>5) 화살표 함수  <strong class="fc_blue">[ES6] ex) const add = (x, y) => x + y;</strong>
            <ul class="dash_list">
                <li>항상 익명함수로 정의한다. -> 26.3절에서 더 정확하게 나옴</li>
            </ul>
        </p>
        <h4>3. 다양한 함수의 형태</h4>
        <p>1) 즉시 실행 함수  <strong class="fc_blue">ex) (function(){var a = 3; var b = 2; return a*b; }();); -> (); :는 함수 호출 연산자임</strong>
            <ul class="dash_list">
                <li>익명함수를 사용하는 것이 일반적이다.</li>
                <li>즉시 실행 함수는 한번만 호출되며 다시 호출할 수 없다.</li>
                <li>반드시 그룹연산자(..)로 감싸야 한다.</li>
                <li>일반 함수 처럼 값을 반환할 수 있고 인수를 전달할 수 있다!</li>
                <li></li>
            </ul>
        </p>
        <p>2) 재귀 함수: 자기 자신을 호출하는 행위, 즉 재귀 호출을 수행하는 함수를 말한다.</p>
        <p>3) 중첩 함수: 함수 내</p>
        <p></p>
        <p></p>
        <p></p>
        <p></p>
        <hr>
        <h2>단축어</h2>
        <p>터미널: cmd + ;</p>
        <p>ctl + option + n: 현재 포커스된 js파일이 살행됨</p>
        <p>f5: cmd + R</p>
    </body>
</html>

